{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>A <code>placeholder</code> uses operator overloading to create partially bound functions on-the-fly. When used in a binary expression, it will return a callable object with the other argument bound. It's useful for replacing <code>lambda</code> in functional programming, and resembles Scala's placeholders.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code>from placeholder import _     # single underscore\n\n_.age &lt; 18     # lambda obj: obj.age &lt; 18\n_[key] ** 2    # lambda obj: obj[key] ** 2\n</code></pre> <p>Note <code>_</code> has special meaning in other contexts, such as the previous output in interactive shells. Assign to a different name as needed. Kotlin uses <code>it</code>, but in Python <code>it</code> is a common short name for an iterator.</p> <p><code>_</code> is a singleton of an <code>F</code> class, and <code>F</code> expressions can also be used with functions.</p> <pre><code>from placeholder import F\n\n-F(len)        # lambda obj: -len(obj)\n</code></pre> <p>All applicable double underscore methods are supported.</p>"},{"location":"#performance","title":"Performance","text":"<p>Every effort is made to optimize the placeholder instance. It's 20-40x faster than similar libraries on PyPI.</p> <p>Placeholders are also iterable, allowing direct access to the underlying functions.</p> <pre><code>(func,) = _.age  # operator.attrgetter('age')\n</code></pre> <p>Performance should generally be comparable to inlined expressions, and faster than lambda. Below are some example benchmarks.</p> <pre><code>min(data, key=operator.itemgetter(-1))    # 1x\nmin(data, key=_[-1])                      # 1.3x\nmin(data, key=lambda x: x[-1])            # 1.6x\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>% pip install placeholder\n</code></pre>"},{"location":"#tests","title":"Tests","text":"<p>100% branch coverage.</p> <pre><code>% pytest [--cov]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>from placeholder import _ as x\n\nx.real\n</pre> from placeholder import _ as x  x.real Out[1]: <pre>F(operator.attrgetter('real'))</pre> In\u00a0[2]: Copied! <pre>nums = (0 + 2j), (1 + 1j), (2 + 0j)\nmin(nums, key=x.real)\n</pre> nums = (0 + 2j), (1 + 1j), (2 + 0j) min(nums, key=x.real) Out[2]: <pre>2j</pre> In\u00a0[3]: Copied! <pre>min(nums, key=x.imag)\n</pre> min(nums, key=x.imag) Out[3]: <pre>(2+0j)</pre> In\u00a0[4]: Copied! <pre>x[0]\n</pre> x[0] Out[4]: <pre>F(operator.itemgetter(0))</pre> In\u00a0[5]: Copied! <pre>pairs = 'ac', 'bb', 'ca'\nmin(pairs, key=x[0])\n</pre> pairs = 'ac', 'bb', 'ca' min(pairs, key=x[0]) Out[5]: <pre>'ac'</pre> In\u00a0[6]: Copied! <pre>min(pairs, key=x[-1])\n</pre> min(pairs, key=x[-1]) Out[6]: <pre>'ca'</pre> In\u00a0[7]: Copied! <pre>import itertools\n\nlist(itertools.accumulate(range(1, 6), x * x))\n</pre> import itertools  list(itertools.accumulate(range(1, 6), x * x)) Out[7]: <pre>[1, 2, 6, 24, 120]</pre> In\u00a0[8]: Copied! <pre>list(itertools.filterfalse(x % 2, range(10)))\n</pre> list(itertools.filterfalse(x % 2, range(10))) Out[8]: <pre>[0, 2, 4, 6, 8]</pre> In\u00a0[9]: Copied! <pre>list(filter(x % 2 == 0, range(10)))\n</pre> list(filter(x % 2 == 0, range(10))) Out[9]: <pre>[0, 2, 4, 6, 8]</pre> In\u00a0[10]: Copied! <pre>list(filter(abs(x) &lt; 1, [-1, 0, 1]))\n</pre> list(filter(abs(x) &lt; 1, [-1, 0, 1])) Out[10]: <pre>[0]</pre> In\u00a0[11]: Copied! <pre>from placeholder import m\n\nm('real', 'imag')\n</pre> from placeholder import m  m('real', 'imag') Out[11]: <pre>F(operator.attrgetter('real', 'imag'))</pre> In\u00a0[12]: Copied! <pre>m[0, -1]\n</pre> m[0, -1] Out[12]: <pre>F(operator.itemgetter(0, -1))</pre> In\u00a0[13]: Copied! <pre>m.split('-')\n</pre> m.split('-') Out[13]: <pre>F(operator.methodcaller('split', '-'))</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":""},{"location":"examples/#f-and-_-singleton","title":"<code>F</code> and <code>_</code> (singleton)\u00b6","text":"<p>IPython uses <code>_</code> as the previous output, so <code>x</code> is used here instead.</p>"},{"location":"examples/#m-and-m-singleton","title":"<code>M</code> and <code>m</code> (singleton)\u00b6","text":"<p>Support for <code>attrgetter(*)</code>, <code>itemgetter(*)</code>, and <code>methodcaller</code>.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#placeholder.F","title":"<code>placeholder.F</code>","text":"<p>               Bases: <code>partial</code></p> <p>Singleton for creating composite functions.</p> <p>Parameters:</p> Name Type Description Default <code>*funcs</code> <code>Callable</code> <p>ordered callables</p> required Source code in <code>placeholder/__init__.py</code> <pre><code>class F(partial):\n    \"\"\"Singleton for creating composite functions.\n\n    Args:\n        *funcs (Callable): ordered callables\n    \"\"\"\n\n    def __new__(cls, *funcs):\n        funcs = (func if isinstance(func, cls) else [func] for func in funcs)\n        funcs = tuple(itertools.chain(*funcs))\n        return partial.__new__(cls, *(funcs if len(funcs) == 1 else (pipe, funcs)))\n\n    def __iter__(self) -&gt; Iterator[Callable]:\n        \"\"\"Return composed functions in order.\"\"\"\n        args = super().__getattribute__('args')\n        return iter(args[0] if args else [super().__getattribute__('func')])\n\n    def __getattribute__(self, attr: str) -&gt; 'F':\n        \"\"\"Return `attrgetter`.\"\"\"\n        if attr.startswith('__') and attr.endswith('__'):\n            return super().__getattribute__(attr)\n        return type(self)(self, operator.attrgetter(attr))\n\n    def __getitem__(self, item) -&gt; 'F':\n        \"\"\"Return `itemgetter`.\"\"\"\n        return type(self)(self, operator.itemgetter(item))\n\n    def __round__(self, ndigits: int | None = None) -&gt; 'F':\n        \"\"\"Return `round(...)`.\"\"\"\n        return type(self)(self, round if ndigits is None else partial(round, ndigits=ndigits))\n\n    __neg__ = unary(operator.neg)\n    __pos__ = unary(operator.pos)\n    __invert__ = unary(operator.invert)\n\n    __abs__ = unary(abs)\n    __reversed__ = unary(reversed)\n\n    __trunc__ = unary(math.trunc)\n    __floor__ = unary(math.floor)\n    __ceil__ = unary(math.ceil)\n\n    __add__, __radd__ = methods(operator.add)\n    __sub__, __rsub__ = methods(operator.sub)\n    __mul__, __rmul__ = methods(operator.mul)\n    __floordiv__, __rfloordiv__ = methods(operator.floordiv)\n    __truediv__, __rtruediv__ = methods(operator.truediv)\n\n    __mod__, __rmod__ = methods(operator.mod)\n    __divmod__, __rdivmod__ = methods(divmod)\n    __pow__, __rpow__ = methods(operator.pow)\n    __matmul__, __rmatmul__ = methods(operator.matmul)\n\n    __lshift__, __rlshift__ = methods(operator.lshift)\n    __rshift__, __rrshift__ = methods(operator.rshift)\n\n    __and__, __rand__ = methods(operator.and_)\n    __xor__, __rxor__ = methods(operator.xor)\n    __or__, __ror__ = methods(operator.or_)\n\n    __eq__ = methods(operator.eq)[0]\n    __ne__ = methods(operator.ne)[0]\n    __lt__, __gt__ = methods(operator.lt)\n    __le__, __ge__ = methods(operator.le)\n</code></pre>"},{"location":"reference/#placeholder.F.__getattribute__","title":"<code>__getattribute__(attr)</code>","text":"<p>Return <code>attrgetter</code>.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __getattribute__(self, attr: str) -&gt; 'F':\n    \"\"\"Return `attrgetter`.\"\"\"\n    if attr.startswith('__') and attr.endswith('__'):\n        return super().__getattribute__(attr)\n    return type(self)(self, operator.attrgetter(attr))\n</code></pre>"},{"location":"reference/#placeholder.F.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Return <code>itemgetter</code>.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __getitem__(self, item) -&gt; 'F':\n    \"\"\"Return `itemgetter`.\"\"\"\n    return type(self)(self, operator.itemgetter(item))\n</code></pre>"},{"location":"reference/#placeholder.F.__iter__","title":"<code>__iter__()</code>","text":"<p>Return composed functions in order.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Callable]:\n    \"\"\"Return composed functions in order.\"\"\"\n    args = super().__getattribute__('args')\n    return iter(args[0] if args else [super().__getattribute__('func')])\n</code></pre>"},{"location":"reference/#placeholder.F.__round__","title":"<code>__round__(ndigits=None)</code>","text":"<p>Return <code>round(...)</code>.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; 'F':\n    \"\"\"Return `round(...)`.\"\"\"\n    return type(self)(self, round if ndigits is None else partial(round, ndigits=ndigits))\n</code></pre>"},{"location":"reference/#placeholder.M","title":"<code>placeholder.M</code>","text":"<p>Singleton for creating method callers and multi-valued getters.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>class M:\n    \"\"\"Singleton for creating method callers and multi-valued getters.\"\"\"\n\n    def __getattr__(cls, name: str) -&gt; F:\n        \"\"\"Return a `methodcaller` constructor.\"\"\"\n        return F(partial(operator.methodcaller, name), F)\n\n    def __call__(self, *names: str) -&gt; F:\n        \"\"\"Return a tupled `attrgetter`.\"\"\"\n        return F(operator.attrgetter(*names))\n\n    def __getitem__(self, keys: Iterable) -&gt; F:\n        \"\"\"Return a tupled `itemgetter`.\"\"\"\n        return F(operator.itemgetter(*keys))\n</code></pre>"},{"location":"reference/#placeholder.M.__call__","title":"<code>__call__(*names)</code>","text":"<p>Return a tupled <code>attrgetter</code>.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __call__(self, *names: str) -&gt; F:\n    \"\"\"Return a tupled `attrgetter`.\"\"\"\n    return F(operator.attrgetter(*names))\n</code></pre>"},{"location":"reference/#placeholder.M.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Return a <code>methodcaller</code> constructor.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __getattr__(cls, name: str) -&gt; F:\n    \"\"\"Return a `methodcaller` constructor.\"\"\"\n    return F(partial(operator.methodcaller, name), F)\n</code></pre>"},{"location":"reference/#placeholder.M.__getitem__","title":"<code>__getitem__(keys)</code>","text":"<p>Return a tupled <code>itemgetter</code>.</p> Source code in <code>placeholder/__init__.py</code> <pre><code>def __getitem__(self, keys: Iterable) -&gt; F:\n    \"\"\"Return a tupled `itemgetter`.\"\"\"\n    return F(operator.itemgetter(*keys))\n</code></pre>"}]}